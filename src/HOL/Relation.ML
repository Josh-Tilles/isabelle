
(* legacy ML bindings *)

val DomainE = thm "DomainE";
val DomainI = thm "DomainI";
val Domain_Collect_split = thm "Domain_Collect_split";
val Domain_Diff_subset = thm "Domain_Diff_subset";
val Domain_Id = thm "Domain_Id";
val Domain_Int_subset = thm "Domain_Int_subset";
val Domain_Un_eq = thm "Domain_Un_eq";
val Domain_Union = thm "Domain_Union";
val Domain_def = thm "Domain_def";
val Domain_diag = thm "Domain_diag";
val Domain_empty = thm "Domain_empty";
val Domain_iff = thm "Domain_iff";
val Domain_insert = thm "Domain_insert";
val Domain_mono = thm "Domain_mono";
val Field_def = thm "Field_def";
val IdE = thm "IdE";
val IdI = thm "IdI";
val Id_O_R = thm "Id_O_R";
val Id_def = thm "Id_def";
val ImageE = thm "ImageE";
val ImageI = thm "ImageI";
val Image_Collect_split = thm "Image_Collect_split";
val Image_INT_subset = thm "Image_INT_subset";
val Image_Id = thm "Image_Id";
val Image_Int_subset = thm "Image_Int_subset";
val Image_UN = thm "Image_UN";
val Image_Un = thm "Image_Un";
val Image_def = thm "Image_def";
val Image_diag = thm "Image_diag";
val Image_empty = thm "Image_empty";
val Image_eq_UN = thm "Image_eq_UN";
val Image_iff = thm "Image_iff";
val Image_mono = thm "Image_mono";
val Image_singleton = thm "Image_singleton";
val Image_singleton_iff = thm "Image_singleton_iff";
val Image_subset = thm "Image_subset";
val Image_subset_eq = thm "Image_subset_eq";
val O_assoc = thm "O_assoc";
val R_O_Id = thm "R_O_Id";
val RangeE = thm "RangeE";
val RangeI = thm "RangeI";
val Range_Collect_split = thm "Range_Collect_split";
val Range_Diff_subset = thm "Range_Diff_subset";
val Range_Id = thm "Range_Id";
val Range_Int_subset = thm "Range_Int_subset";
val Range_Un_eq = thm "Range_Un_eq";
val Range_Union = thm "Range_Union";
val Range_def = thm "Range_def";
val Range_diag = thm "Range_diag";
val Range_empty = thm "Range_empty";
val Range_iff = thm "Range_iff";
val Range_insert = thm "Range_insert";
val antisymD = thm "antisymD";
val antisymI = thm "antisymI";
val antisym_Id = thm "antisym_Id";
val antisym_converse = thm "antisym_converse";
val antisym_def = thm "antisym_def";
val converseD = thm "converseD";
val converseE = thm "converseE";
val converseI = thm "converseI";
val converse_Id = thm "converse_Id";
val converse_converse = thm "converse_converse";
val converse_def = thm "converse_def";
val converse_diag = thm "converse_diag";
val converse_iff = thm "converse_iff";
val converse_rel_comp = thm "converse_rel_comp";
val diagE = thm "diagE";
val diagI = thm "diagI";
val diag_def = thm "diag_def";
val diag_eqI = thm "diag_eqI";
val diag_iff = thm "diag_iff";
val diag_subset_Times = thm "diag_subset_Times";
val fun_rel_comp_def = thm "fun_rel_comp_def";
val fun_rel_comp_mono = thm "fun_rel_comp_mono";
val fun_rel_comp_unique = thm "fun_rel_comp_unique";
val inv_image_def = thm "inv_image_def";
val pair_in_Id_conv = thm "pair_in_Id_conv";
val reflD = thm "reflD";
val reflI = thm "reflI";
val refl_converse = thm "refl_converse";
val refl_def = thm "refl_def";
val reflexive_Id = thm "reflexive_Id";
val rel_compE = thm "rel_compE";
val rel_compEpair = thm "rel_compEpair";
val rel_compI = thm "rel_compI";
val rel_comp_def = thm "rel_comp_def";
val rel_comp_mono = thm "rel_comp_mono";
val rel_comp_subset_Sigma = thm "rel_comp_subset_Sigma";
val rev_ImageI = thm "rev_ImageI";
val single_valuedD = thm "single_valuedD";
val single_valuedI = thm "single_valuedI";
val single_valued_def = thm "single_valued_def";
val sym_def = thm "sym_def";
val transD = thm "transD";
val transI = thm "transI";
val trans_Id = thm "trans_Id";
val trans_O_subset = thm "trans_O_subset";
val trans_converse = thm "trans_converse";
val trans_def = thm "trans_def";
val trans_inv_image = thm "trans_inv_image";
